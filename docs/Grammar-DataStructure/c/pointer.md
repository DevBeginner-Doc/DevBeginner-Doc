::: warning :construction:WARNING
本条目仍在积极施工中，可能存在遗漏或不完善的地方
:::

# 指针

指针是 C 语言中一个非常强大且重要的概念。指针提供了直接访问内存地址的能力，可以用来操作数组、动态内存分配、函数参数传递等。

## (一)&nbsp;指针是什么？

指针是一个变量，与之前的变量不同，它保存了内存地址，而不是变量的值。指针变量的大小和普通变量一样，指针变量的值也是由操作系统分配的。指针变量的值是内存地址，而内存地址是 $8$ 字节。

```c
int i = 7;
int *p = &i;//&是取地址运算符，用来获取指定变量的地址(即找到这个变量的值存在哪)
//也可以写成int* p = &i;星号靠前靠后无所谓
```

## (二)&nbsp;指针与函数

指针与函数之间是紧密相连的，指针可以作为函数的参数传递，函数也可以返回指针。

```c
#include<stdio.h>
void arrayMax(int *b);
void myfunction1(int *p){
    printf("%d\n",*p);//*是解引用运算符，用它来获取指针p所指向的内存地址上的值
    //在这个函数中可以通过指针来访问那个地址，从而获取那个地址上的值，或者修改那个地址上的值
    *p = 10;//通过指针p修改它所指向的内存地址上的值
    printf("%d\n",*p);
    return;
}
int main(){
    int a = 9;
    myfunction1(&a);//传递的是a的地址
    printf("%d\n",a);//a的值被修改了

    int b[] = {1,2,3,4,5,6,7,8,9,10};
    arrayMax(b);
    return 0;
}
//数组其实是一个指针，比如我们刚刚定义的那个数组b，其实b就是一个指针，它指向数组的第一个元素
//*b和b[0]是等价的

//int *p = b;(创建一个指向数组首元素的指针)。它与int *p = &b[0]是等价的

//函数参数表中的数组本质也是指针，我们只是传入了数组首元素的地址，
//下面这个函数的参数表中的int *b可以替换为int b[]
void arrayMax(int *b){
    int max = b[0];
    for(int i = 1; i < 10; i++){
        if(b[i] > max){
            max = b[i];
        }
    }
    printf("数组中最大的数是%d\n",max);
    return;
}
```

## (三)&nbsp;指针的赋值

我们前面提过，数组变量不能互相赋值，像下面这样的写法是不对的：

```c
int a[] = {1,2,3,4,5,6,7,8,9,10};
int b[] = a; // [!code error]
```

但是指向相同类型变量的指针变量是可以互相赋值的，如下面的代码：

```c
#include <stdio.h>
int main() {
    int num1 = 10;
    int *ptr1 = &num1;  // 指针ptr1指向num1的内存地址

    int *ptr2;
    ptr2 = ptr1;  // 将ptr1的值赋给ptr2

    printf("num1 = %d\n", num1);
    printf("ptr1 = %p\n", ptr1);// 输出ptr1存储的那个的地址
    printf("ptr2 = %p\n", ptr2);// 输出ptr2存储的那个的地址
    printf("*ptr1 = %d\n", *ptr1);// 输出ptr1指向的地址存储的数值
    printf("*ptr2 = %d\n", *ptr2);// 输出ptr2指向的地址存储的数值
    return 0;
}
```

:::warning
指向不同类型变量的指针不能互相赋值，如下面的代码：

```c
#include<stdio.h>
int main(){
    int i = 10;
    int *p = &i;
    char *q;
    //下面这样赋值时错误的
    p = q;// [!code error]
    return 0;
}

```
:::

## (四)&nbsp;指向指针的指针

指针存储了它指向的变量的地址，指针的指针存储了它指向的指针的地址。

```c
#include <stdio.h>
int main() {
    int num1 = 10;
    int *ptr1 = &num1;  // 指针ptr1指向num1的内存地址

    int **ptr2 = &ptr1;  // 将ptr1的地址赋给ptr2
    /*注意，这个地址指的不是ptr1指向的地址，
      而是ptr1变量本身在内存中的存储地址
      可以理解成ptr2指向ptr1，ptr1指向num1
    */
    printf("num1 = %d\n", num1);
    printf("ptr1 = %p\n", ptr1);// 输出ptr1存储的那个的地址
    printf("ptr2 = %p\n", ptr2);// 输出ptr2存储的那个的地址
    printf("*ptr1 = %d\n", *ptr1);// 输出ptr1指向的地址存储的数值
    printf("**ptr2 = %d\n", **ptr2);// 输出ptr2指向的地址存储的数值
    return 0;
}
```

## (五)&nbsp;const 修饰的指针

在C语言中，`const` 是一个关键字，用于声明常量。常量是在程序运行期间不可修改的值。

```c
#include <stdio.h>
int main() {
    const int a = 99;//声明一个常量a，它的值为99，a的值不能被更改
    int i = 10;
    int * const q = &i;
    //指针q只能指向i，不能再指向其他变量
    const int * p = &i;
    //指针p只能读取i的值，不能通过指针p修改i的值，但是可以直接修改i的值
    *q = 20;
    //q指向的i的值被修改为20
    return 0;
}
```

## (六)&nbsp;指针参与的运算

```c
#include<stdio.h>
int main(){
    char ab[] = {0,1,9,3,7};
    char *p = ab;
    printf("%p %p\n",p,p+1);/*我们可以发现输出的两个十六进制数值相差为1
    这是因为对指针做加一操作时它会移动到下一个存储单元，
    每个存储单元的大小取决于它们的数据类型(结构体这个特例我们后面会说)
    p指向的是一个字符数组，每个字符的大小为1字节，所以指针p加1就指向下一个字符
    如果数组类型换成int的话就是后移4个字节，因为int的大小为4字节
    */

    //循环输出数组中每个元素
    //实质是访问p指向的元素、p加1后指向的元素、p加2后指向的元素…………
    for(int i = 0; i < 5; i++){
        printf("%d ",*(p+i));
        /*这里*(p+i)换成*p++效果是一样的，
        它的意思是先访问p指向的变量的值，再让p向后移动一个存储单元
        实在记不住优先级可以试试用括号，保证程序按照你想要的方式运行，
        比如写成(*p)++，保证解引用运算先进行
        */
    }
    return 0;
}
```

对指针进行大于、小于、大于等于、小于等于、等于、不等于这些运算符，都是用来比较两个指针变量的地址值(这么比除了看谁存储的位置靠前、谁靠后以外，好像没什么意义)，并不是来比较指针指向的内存地址上的内容谁大谁小。

## (七)&nbsp;*p 与 p 的区分

之前我们定义了一个指针变量：

```c
int *p;
```

你可能对 `*p` 和 `p` 的区别有点迷糊，`*p` 是用来获取指针 `p` 所指向的内存地址上的内容。而 `p` 是一个名为 `p` 的指针变量，它存储的是一个地址。

## (八)&nbsp;指针的类型转换(慎用)

指针类型转换是C语言中比较常见的操作，但是它并不是一个安全的操作，因为它可能会导致程序崩溃。

比如下面这个代码：

```c
void * p1;//一个不知道指向什么东西的指针
int i = 9;
int *p = &i;
void *q = (void *)p;
```

这个类型转换方式我们一般用不到，后面我们讲C语言的 `qsort` 函数的时候可能会小小的用一下。

## (九)&nbsp;空指针

如果一个指针不指向任何数据，我们就称之为空指针 ，用 `NULL` 表示。例如：

```c
int *p = NULL;
```

注意区分大小写，`null` 没有任何特殊含义，只是一个普通的标识符。`NULL` 是一个宏定义，在 `stdio.h` 被定义为：

```c
#define NULL ((void *)0)
```

宏我们后面会讲，这里只需要知道写了 `#define 宏名 宏定义值` 之后，编译器在编译时会自动把宏名替换成宏定义值。

```c
//比如
#include<stdio.h>
#define int long long
//那么在编译的时候，编译器会把当前文件中所有的int替换成long long
//main函数那边可以用signed代替int(它们两个等价)，不然会报错
signed main(){
    //略
    return 0;
}
```

说完 `NULL` ，我们接着来说空指针：

```c
int *p = NULL;
int *p;
//这两种声明是不一样的，第一个是个空指针，而第二个则是指向一个未知未知的指针，如果随意使用的话，可能导致程序崩溃
```
